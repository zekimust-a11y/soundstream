import https from 'https';
import crypto from 'crypto';

export interface TidalConfig {
  clientId: string;
  clientSecret?: string; // Optional for public client IDs
  accessToken?: string;
  refreshToken?: string;
  userId?: string;
}

export interface TidalAlbum {
  id: string;
  title: string;
  artist: {
    id: string;
    name: string;
  };
  cover?: string;
  year?: number;
  numberOfTracks?: number;
  duration?: number;
  lmsUri: string; // LMS playable URI like "tidal://album:233036"
}

export interface TidalTrack {
  id: string;
  title: string;
  artist: {
    id: string;
    name: string;
  };
  album: {
    id: string;
    title: string;
  };
  duration: number;
  trackNumber?: number;
  cover?: string;
  audioQuality?: string;
  lmsUri: string; // LMS playable URI like "tidal://track:12345"
}

export interface TidalArtist {
  id: string;
  name: string;
  picture?: string;
}

export interface TidalPlaylist {
  id: string;
  title: string;
  description?: string;
  creator?: {
    id: string;
    name: string;
  };
  numberOfTracks?: number;
  duration?: number;
  cover?: string;
  lastUpdated?: string;
}

// Fallback client IDs for rotation if needed
const TIDAL_FALLBACK_IDS = [
  'pUlCxd80DuDSem4J', // Default
  '7m7Ap0JC9j1cOM3n', // Alternative 1
  'zU4XHVVkc2tDP8X',  // Alternative 2
  'OmDtrzFZSg8Ff2e',  // Alternative 3
  'KMZrGg3rJQJcZz9',  // Alternative 4
];

export class TidalApiClient {
  private config: TidalConfig;
  private authenticated: boolean = false;
  private codeVerifier: string | null = null;
  private codeChallenge: string | null = null;
  private currentClientIdIndex: number = 0;
  private onTokensRefreshed?: (tokens: { accessToken: string; refreshToken: string; userId?: string }) => void;

  constructor(config: TidalConfig, onTokensRefreshed?: (tokens: { accessToken: string; refreshToken: string; userId?: string }) => void) {
    this.config = config;
    this.onTokensRefreshed = onTokensRefreshed;
    // Set to the primary client ID by default
    this.currentClientIdIndex = 0; // Use 'pUlCxd80DuDSem4J'
    this.config.clientId = TIDAL_FALLBACK_IDS[this.currentClientIdIndex];
    console.log(`[TidalApiClient] Initialized with Client ID: ${this.config.clientId}`);
  }

  public cycleClientId(): string {
    this.currentClientIdIndex = (this.currentClientIdIndex + 1) % TIDAL_FALLBACK_IDS.length;
    this.config.clientId = TIDAL_FALLBACK_IDS[this.currentClientIdIndex];
    console.log(`[TidalApiClient] Cycled to Client ID: ${this.config.clientId} (index: ${this.currentClientIdIndex})`);
    return this.config.clientId;
  }

  public getClientId(): string {
    return this.config.clientId;
  }

  async authenticate(): Promise<boolean> {
    try {
      if (this.config.accessToken) {
        // Test the token by making a simple API call - use openapi /v1/sessions
        try {
          await this.makeRequest('/v1/sessions');
          console.log('[TidalApiClient] Authenticated with stored tokens');
          this.authenticated = true;
          return true;
        } catch (e) {
          console.log('[TidalApiClient] Session validation failed:', e instanceof Error ? e.message : String(e));
          // Don't mark as authenticated if we can't even get session
          this.authenticated = false;
          return false;
        }
      } else {
        console.log('[TidalApiClient] No access token available');
        this.authenticated = false;
        return false;
      }
    } catch (error) {
      console.error('[TidalApiClient] Authentication failed:', error);
      this.authenticated = false;
      return false;
    }
  }

  isAuthenticated(): boolean {
    return this.authenticated;
  }

  async refreshAccessToken(): Promise<boolean> {
    if (!this.config.refreshToken) {
      console.warn('[TidalApiClient] No refresh token available');
      return false;
    }

    console.log('[TidalApiClient] Refreshing access token...');
    const tokenUrl = 'https://login.tidal.com/oauth2/token';
    const params = new URLSearchParams({
      grant_type: 'refresh_token',
      refresh_token: this.config.refreshToken,
      client_id: this.config.clientId,
    });

    const auth = Buffer.from(`${this.config.clientId}:${this.config.clientSecret || ''}`).toString('base64');

    try {
      const tokenData = await new Promise<any>((resolve, reject) => {
        const req = https.request(tokenUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Authorization': `Basic ${auth}`,
          },
        }, (res) => {
          let data = '';
          res.on('data', (chunk) => data += chunk);
          res.on('end', () => {
            try {
              if (res.statusCode === 200) {
                resolve(JSON.parse(data));
              } else {
                reject(new Error(`Refresh failed: ${res.statusCode} - ${data}`));
              }
            } catch (e) {
              reject(new Error(`Failed to parse refresh response: ${e}`));
            }
          });
        });
        req.on('error', (error) => reject(error));
        req.write(params.toString());
        req.end();
      });

      if (tokenData.access_token) {
        this.config.accessToken = tokenData.access_token;
        if (tokenData.refresh_token) {
          this.config.refreshToken = tokenData.refresh_token;
        }
        this.authenticated = true;
        
        console.log('[TidalApiClient] Access token refreshed successfully');
        
        if (this.onTokensRefreshed) {
          this.onTokensRefreshed({
            accessToken: this.config.accessToken,
            refreshToken: this.config.refreshToken!,
            userId: this.config.userId,
          });
        }
        return true;
      }
      return false;
    } catch (error) {
      console.error('[TidalApiClient] Failed to refresh token:', error);
      this.authenticated = false;
      return false;
    }
  }

  private async makeRequest(endpoint: string, options: { method?: string; body?: any; countryCode?: string; retryCount?: number } = {}): Promise<any> {
    // Use Tidal OpenAPI endpoints (openapi.tidal.com) for modern scopes
    const baseUrl = 'https://openapi.tidal.com';
    const countryCode = options.countryCode || 'US';
    const separator = endpoint.includes('?') ? '&' : '?';
    const url = `${baseUrl}${endpoint}${separator}countryCode=${countryCode}`;
    
    console.log(`[TidalApiClient] Requesting: ${url}`);
    
    const headers: Record<string, string> = {
      'Authorization': `Bearer ${this.config.accessToken}`,
      'accept': 'application/vnd.tidal.v1+json',
      'Content-Type': 'application/vnd.tidal.v1+json',
    };

    const requestOptions = {
      method: options.method || 'GET',
      headers,
    };

    return new Promise((resolve, reject) => {
      const req = https.request(url, requestOptions, (res) => {
        let data = '';
        res.on('data', (chunk) => {
          data += chunk;
        });
        res.on('end', async () => {
          try {
            if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
              const json = JSON.parse(data || '{}');
              resolve(json);
            } else if (res.statusCode === 401 && (!options.retryCount || options.retryCount < 1)) {
              console.log('[TidalApiClient] 401 Unauthorized, attempting token refresh...');
              const refreshed = await this.refreshAccessToken();
              if (refreshed) {
                try {
                  const retryResult = await this.makeRequest(endpoint, { ...options, retryCount: (options.retryCount || 0) + 1 });
                  resolve(retryResult);
                } catch (retryError) {
                  reject(retryError);
                }
              } else {
                reject(new Error(`Tidal API error: ${res.statusCode} - ${data || 'Unauthorized'}`));
              }
            } else {
              console.error(`[TidalApiClient] API Error ${res.statusCode}:`, data);
              reject(new Error(`Tidal API error: ${res.statusCode} - ${data || 'Unknown error'}`));
            }
          } catch (e) {
            reject(new Error(`Failed to parse Tidal API response: ${e}`));
          }
        });
      });

      req.on('error', (error) => {
        reject(new Error(`Tidal API request failed: ${error.message}`));
      });

      if (options.body) {
        req.write(JSON.stringify(options.body));
      }

      req.setTimeout(10000, () => {
        req.destroy();
        reject(new Error('Tidal API request timeout'));
      });

      req.end();
    });
  }

  async getMyAlbums(limit: number = 50, offset: number = 0): Promise<{ items: TidalAlbum[]; total: number }> {
    if (!this.authenticated || !this.config.accessToken) {
      throw new Error('Not authenticated with Tidal');
    }

    try {
      const result = await this.makeRequest(`/v1/my/collection/albums?limit=${limit}&offset=${offset}`);
      return {
        items: (result.data || []).map((item: any) => this.mapAlbum(item.resource || item)),
        total: result.metadata?.totalNumberOfItems || result.data?.length || 0,
      };
    } catch (error) {
      console.error('[TidalApiClient] Failed to get albums:', error);
      throw error;
    }
  }

  async getMyPlaylists(limit: number = 50, offset: number = 0): Promise<{ items: TidalPlaylist[]; total: number }> {
    if (!this.authenticated || !this.config.accessToken) {
      throw new Error('Not authenticated with Tidal');
    }

    try {
      const result = await this.makeRequest(`/v1/my/playlists?limit=${limit}&offset=${offset}`);
      return {
        items: (result.data || []).map((item: any) => this.mapPlaylist(item)),
        total: result.metadata?.totalNumberOfItems || result.data?.length || 0,
      };
    } catch (error) {
      console.error('[TidalApiClient] Failed to get playlists:', error);
      throw error;
    }
  }

  async getMyArtists(limit: number = 50, offset: number = 0): Promise<{ items: TidalArtist[]; total: number }> {
    if (!this.authenticated || !this.config.accessToken) {
      throw new Error('Not authenticated with Tidal');
    }

    try {
      const result = await this.makeRequest(`/v1/my/collection/artists?limit=${limit}&offset=${offset}`);
      return {
        items: (result.data || []).map((item: any) => this.mapArtist(item.resource || item)),
        total: result.metadata?.totalNumberOfItems || result.data?.length || 0,
      };
    } catch (error) {
      console.error('[TidalApiClient] Failed to get artists:', error);
      throw error;
    }
  }

  async getAlbumTracks(albumId: string): Promise<TidalTrack[]> {
    if (!this.authenticated || !this.config.accessToken) {
      throw new Error('Not authenticated with Tidal');
    }

    try {
      const result = await this.makeRequest(`/v1/albums/${albumId}/tracks`);
      return (result.data || []).map((item: any) => this.mapTrack(item));
    } catch (error) {
      console.error(`[TidalApiClient] Failed to get album tracks for ${albumId}:`, error);
      throw error;
    }
  }

  async getPlaylistTracks(playlistId: string): Promise<TidalTrack[]> {
    if (!this.authenticated || !this.config.accessToken) {
      throw new Error('Not authenticated with Tidal');
    }

    try {
      const result = await this.makeRequest(`/v1/playlists/${playlistId}/tracks`);
      return (result.data || []).map((item: any) => this.mapTrack(item));
    } catch (error) {
      console.error(`[TidalApiClient] Failed to get playlist tracks for ${playlistId}:`, error);
      throw error;
    }
  }

  async searchAlbums(query: string, limit: number = 20): Promise<TidalAlbum[]> {
    if (!this.authenticated || !this.config.accessToken) {
      throw new Error('Not authenticated with Tidal');
    }

    try {
      const result = await this.makeRequest(`/v1/search?query=${encodeURIComponent(query)}&type=ALBUMS&limit=${limit}`);
      return (result.albums?.data || []).map((item: any) => this.mapAlbum(item));
    } catch (error) {
      console.error(`[TidalApiClient] Failed to search albums for "${query}":`, error);
      throw error;
    }
  }

  async searchArtists(query: string, limit: number = 20): Promise<TidalArtist[]> {
    if (!this.authenticated || !this.config.accessToken) {
      throw new Error('Not authenticated with Tidal');
    }

    try {
      const result = await this.makeRequest(`/v1/search?query=${encodeURIComponent(query)}&type=ARTISTS&limit=${limit}`);
      return (result.artists?.data || []).map((item: any) => this.mapArtist(item));
    } catch (error) {
      console.error(`[TidalApiClient] Failed to search artists for "${query}":`, error);
      throw error;
    }
  }

  async searchTracks(query: string, limit: number = 20): Promise<TidalTrack[]> {
    if (!this.authenticated || !this.config.accessToken) {
      throw new Error('Not authenticated with Tidal');
    }

    try {
      const result = await this.makeRequest(`/v1/search?query=${encodeURIComponent(query)}&type=TRACKS&limit=${limit}`);
      return (result.tracks?.data || []).map((item: any) => this.mapTrack(item));
    } catch (error) {
      console.error(`[TidalApiClient] Failed to search tracks for "${query}":`, error);
      throw error;
    }
  }

  async getLibraryTotals(): Promise<{ albums: number; artists: number; tracks: number; playlists: number }> {
    if (!this.authenticated || !this.config.accessToken) {
      return { albums: 0, artists: 0, tracks: 0, playlists: 0 };
    }

    try {
      const [albums, artists, playlists] = await Promise.all([
        this.makeRequest(`/v1/my/collection/albums?limit=1`).catch(() => ({ metadata: { totalNumberOfItems: 0 } })),
        this.makeRequest(`/v1/my/collection/artists?limit=1`).catch(() => ({ metadata: { totalNumberOfItems: 0 } })),
        this.makeRequest(`/v1/my/playlists?limit=1`).catch(() => ({ metadata: { totalNumberOfItems: 0 } })),
      ]);

      console.log("[TidalApiClient] Raw totals result:", { 
        albums: albums.metadata?.totalNumberOfItems, 
        artists: artists.metadata?.totalNumberOfItems, 
        playlists: playlists.metadata?.totalNumberOfItems 
      });

      return {
        albums: albums.metadata?.totalNumberOfItems || 0,
        artists: artists.metadata?.totalNumberOfItems || 0,
        playlists: playlists.metadata?.totalNumberOfItems || 0,
        tracks: 0, 
      };
    } catch (error) {
      console.error('[TidalApiClient] Failed to get totals:', error);
      return { albums: 0, artists: 0, tracks: 0, playlists: 0 };
    }
  }

  private mapAlbum(album: any): TidalAlbum {
    const resource = album.resource || album;
    return {
      id: String(resource.id),
      title: resource.title || resource.attributes?.title || 'Unknown Album',
      artist: {
        id: String(resource.artist?.id || resource.artists?.[0]?.id || ''),
        name: resource.artist?.name || resource.artists?.[0]?.name || resource.attributes?.artistName || 'Unknown Artist',
      },
      cover: resource.cover || resource.imageId || resource.attributes?.imageLinks?.[0]?.href,
      year: resource.releaseDate ? new Date(resource.releaseDate).getFullYear() : undefined,
      numberOfTracks: resource.numberOfTracks,
      duration: resource.duration,
      lmsUri: `tidal://album:${resource.id}`,
    };
  }

  private mapTrack(track: any): TidalTrack {
    const resource = track.resource || track;
    const artist = resource.artist || resource.artists?.[0] || { id: '', name: 'Unknown Artist' };
    const album = resource.album || { id: '', title: 'Unknown Album' };
    return {
      id: String(resource.id),
      title: resource.title || resource.attributes?.title || 'Unknown Track',
      artist: {
        id: String(artist.id),
        name: artist.name || 'Unknown Artist',
      },
      album: {
        id: String(album.id),
        title: album.title || 'Unknown Album',
      },
      duration: resource.duration || 0,
      trackNumber: resource.trackNumber,
      cover: resource.cover || album.cover || resource.attributes?.imageLinks?.[0]?.href,
      audioQuality: resource.audioQuality,
      lmsUri: `tidal://track:${resource.id}`,
    };
  }

  private mapArtist(artist: any): TidalArtist {
    const resource = artist.resource || artist;
    return {
      id: String(resource.id),
      name: resource.name || resource.attributes?.name || 'Unknown Artist',
      picture: resource.picture || resource.imageId || resource.attributes?.imageLinks?.[0]?.href,
    };
  }

  private mapPlaylist(playlist: any): TidalPlaylist {
    const resource = playlist.resource || playlist;
    return {
      id: String(resource.id),
      title: resource.title || resource.attributes?.title || 'Unknown Playlist',
      description: resource.description || resource.attributes?.description,
      creator: {
        id: '',
        name: 'Tidal',
      },
      numberOfTracks: resource.numberOfTracks,
      duration: resource.duration,
      cover: resource.cover || resource.attributes?.imageLinks?.[0]?.href,
      lastUpdated: resource.lastUpdated,
    };
  }

  generateAuthUrl(redirectUri: string = 'soundstream://callback'): string {
    this.codeVerifier = this.generateCodeVerifier();
    this.codeChallenge = this.generateCodeChallenge(this.codeVerifier);
    const state = crypto.randomBytes(16).toString('hex');

    // EXACT modern Tidal scopes as provided by user
    const scope = 'user.read collection.read search.read playlists.write playlists.read entitlements.read collection.write playback recommendations.read search.write';

    const params = new URLSearchParams({
      response_type: 'code',
      client_id: this.config.clientId,
      redirect_uri: redirectUri,
      scope: scope,
      code_challenge: this.codeChallenge,
      code_challenge_method: 'S256',
      state: state,
    });

    return `https://login.tidal.com/authorize?${params.toString()}`;
  }

  private generateCodeVerifier(): string {
    return crypto.randomBytes(32).toString('base64url');
  }

  private generateCodeChallenge(verifier: string): string {
    const hash = crypto.createHash('sha256').update(verifier).digest();
    return hash.toString('base64url');
  }

  async exchangeCodeForTokens(code: string, redirectUri: string = 'soundstream://callback'): Promise<{ accessToken: string; refreshToken: string; userId?: string }> {
    if (!this.codeVerifier) {
      throw new Error('No code verifier available. Please generate auth URL first.');
    }

    const tokenUrl = 'https://login.tidal.com/oauth2/token';
    const params = new URLSearchParams({
      grant_type: 'authorization_code',
      code: code,
      client_id: this.config.clientId,
      redirect_uri: redirectUri,
      code_verifier: this.codeVerifier,
    });

    const auth = Buffer.from(`${this.config.clientId}:${this.config.clientSecret || ''}`).toString('base64');

    return new Promise((resolve, reject) => {
      const req = https.request(tokenUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Authorization': `Basic ${auth}`,
        },
      }, (res) => {
        let data = '';
        res.on('data', (chunk) => data += chunk);
        res.on('end', () => {
          try {
            if (res.statusCode === 200) {
              const tokenData = JSON.parse(data);
              resolve({
                accessToken: tokenData.access_token,
                refreshToken: tokenData.refresh_token,
                userId: tokenData.user?.id,
              });
            } else {
              reject(new Error(`Token exchange failed: ${res.statusCode} - ${data}`));
            }
          } catch (e) {
            reject(new Error(`Failed to parse token response: ${e}`));
          }
        });
      });

      req.on('error', (error) => {
        reject(new Error(`Token request failed: ${error.message}`));
      });

      req.write(params.toString());
      req.end();
    });
  }

  setTokens(accessToken: string, refreshToken: string, userId?: string) {
    this.config.accessToken = accessToken;
    this.config.refreshToken = refreshToken;
    if (userId) this.config.userId = userId;
  }

  getTokens() {
    return {
      accessToken: this.config.accessToken,
      refreshToken: this.config.refreshToken,
      userId: this.config.userId,
    };
  }
}
