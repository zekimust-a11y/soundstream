<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Now Playing - SoundStream</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        min-height: 100vh;
        overflow: hidden;
        background: #000;
        color: #fff;
      }

      .background-layer {
        position: fixed;
        inset: 0;
        background-size: cover;
        /* Top-align so faces/heads don't get cropped off on TV overscan */
        background-position: center top;
        opacity: 0;
        transition: opacity 1.5s ease-in-out;
        will-change: opacity;
      }

      .background-layer.active {
        opacity: 1;
      }

      .background-layer.blurred {
        filter: blur(40px) brightness(0.35);
        transform: scale(1.08);
      }

      .background-overlay {
        position: fixed;
        inset: 0;
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.15) 0%,
          rgba(0, 0, 0, 0.55) 55%,
          rgba(0, 0, 0, 0.9) 100%
        );
        z-index: 2;
      }

      .bottom-bar {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 32px 60px 40px;
        display: flex;
        gap: 48px;
        align-items: flex-end;
        z-index: 10;
        opacity: 1;
        transition: opacity 0.3s ease;
      }

      .bottom-bar.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .artwork-container {
        width: 33vh;
        height: 33vh;
        max-width: 442px;
        flex-shrink: 0;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 30px 60px rgba(0, 0, 0, 0.8);
        background: rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .artwork {
        width: 100%;
        height: 100%;
        object-fit: cover;
        opacity: 0;
        transition: opacity 0.6s ease;
      }

      .artwork.loaded {
        opacity: 1;
      }

      .info {
        flex: 1;
        min-width: 0;
      }

      .title {
        font-size: 2.184rem;
        font-weight: 700;
        letter-spacing: -0.5px;
        margin-bottom: 6px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .artist-text {
        font-size: 1.3rem;
        color: rgba(255, 255, 255, 0.8);
        margin-bottom: 16px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .progress-row {
        display: flex;
        align-items: center;
        gap: 18px;
      }

      .time {
        width: 70px;
        font-variant-numeric: tabular-nums;
        color: rgba(255, 255, 255, 0.75);
        display: inline-flex;
        align-items: center;
        line-height: 1;
        min-height: 1em;
      }

      .time.duration {
        justify-content: flex-end;
        text-align: right;
      }

      .progress-container {
        flex: 1;
        height: 3px;
        display: flex;
        align-items: center;
        position: relative;
        background: rgba(255, 255, 255, 0.15);
        border-radius: 3px;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #ffffff, rgba(255, 255, 255, 0.9));
        border-radius: 3px;
        transition: width 1s linear;
        width: 0%;
      }

      #volume-overlay {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 32px 48px;
        border-radius: 18px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 20;
      }

      #volume-overlay.visible {
        opacity: 1;
      }

      .volume-icon {
        font-size: 3rem;
      }

      .volume-text {
        font-size: 4.5rem;
        font-weight: 200;
      }

      .mute-text {
        font-size: 2rem;
        letter-spacing: 4px;
        color: #ff6666;
      }

      .not-playing-container {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
        opacity: 1;
        transition: opacity 0.3s ease;
      }

      .not-playing-container.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .not-playing {
        text-align: center;
      }

      .not-playing h2 {
        font-size: 2rem;
        margin-bottom: 12px;
      }

      .not-playing p {
        font-size: 1.2rem;
        color: rgba(255, 255, 255, 0.7);
      }

      /* Cast devices often report ~960px CSS width on 1080p TVs; keep desktop layout for TV. */
      @media (max-width: 850px) {
        .bottom-bar {
          flex-direction: column;
          align-items: center;
        }

        .artwork-container {
          width: 55vw;
          height: 55vw;
        }

        .info {
          width: 100%;
        }

        .title {
          font-size: 1.68rem;
          text-align: center;
        }

        .artist-text {
          text-align: center;
        }

        .progress-row {
          flex-direction: column;
          gap: 10px;
        }

        .progress-container {
          width: 100%;
        }

        .time {
          width: auto;
        }
      }
    </style>
  </head>
  <body>
    <div id="bg-layer-0" class="background-layer active"></div>
    <div id="bg-layer-1" class="background-layer"></div>
    <div class="background-overlay"></div>

    <div class="not-playing-container">
      <div class="not-playing">
        <h2>Connecting to LMS...</h2>
        <p>Please wait</p>
      </div>
    </div>

    <div class="bottom-bar hidden">
      <div class="artwork-container">
        <img id="album-art" class="artwork" alt="Album art" />
      </div>
      <div class="info">
        <h1 class="title"></h1>
        <p class="artist-text"></p>
        <div class="progress-row">
          <span class="time current">0:00</span>
          <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
          </div>
          <span class="time duration">0:00</span>
        </div>
      </div>
    </div>

    <div id="volume-overlay">
      <div id="volume-icon" class="volume-icon">ðŸ”Š</div>
      <div id="volume-value" class="volume-text">0</div>
    </div>

    <script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <script>
      // Cast SDK setup
      const CAST_NAMESPACE = 'urn:x-cast:com.zeki.rooncast';
      const context = cast.framework.CastReceiverContext.getInstance();
      const options = new cast.framework.CastReceiverOptions();
      options.disableIdleTimeout = true;
      
      // Get URL parameters (fallback)
      const params = new URLSearchParams(window.location.search);
      let host = params.get('host') || '';
      let port = params.get('port') || '9000';
      let playerId = params.get('player') || '';
      let serverUrl = '';
      
      // Listen for Cast messages with LMS parameters and server URL
      context.addCustomMessageListener(CAST_NAMESPACE, (event) => {
        console.log('[Cast] Received message:', event.data);
        const data = event.data;
        
        if (data.type === 'SET_LMS_PARAMS') {
          host = data.host || host;
          port = data.port || port;
          playerId = data.player || playerId;
          serverUrl = data.serverUrl || serverUrl;
          
          console.log('[Cast] Updated params:', { host, port, playerId, serverUrl });
          
          // Start polling if we have all required params
          if (host && playerId && serverUrl) {
            startPolling();
          }
        }
      });
      
      context.addEventListener(cast.framework.system.EventType.SENDER_DISCONNECTED, (event) => {
        console.log('Sender disconnected');
      });
      
      context.start(options);
      console.log('[Cast] Receiver started, waiting for parameters...');
      
      if (window.EMBEDDED_PARAMS) {
        host = window.EMBEDDED_PARAMS.host || host;
        port = window.EMBEDDED_PARAMS.port || port;
        playerId = window.EMBEDDED_PARAMS.player || playerId;
        serverUrl = window.EMBEDDED_PARAMS.serverUrl || serverUrl;
      }
      
      if (!host) host = '192.168.0.19';
      if (!port) port = '9000';
      if (!serverUrl) serverUrl = 'http://192.168.0.21:3000';
      
      const AUDIODB_API_KEY = '2';
      const BACKGROUND_ROTATION_MS = 25000;
      
      // Function to get proxy URL dynamically
      function getProxyUrl() {
        return `${serverUrl}/api/lms/proxy`;
      }

      // DOM Elements
      const bgLayers = [
        document.getElementById('bg-layer-0'),
        document.getElementById('bg-layer-1')
      ];
      const titleEl = document.querySelector('.title');
      const artistEl = document.querySelector('.artist-text');
      const currentTimeEl = document.querySelector('.time.current');
      const durationEl = document.querySelector('.time.duration');
      const progressBar = document.getElementById('progress-bar');
      const albumArt = document.getElementById('album-art');
      const bottomBar = document.querySelector('.bottom-bar');
      const notPlayingContainer = document.querySelector('.not-playing-container');
      const volumeOverlay = document.getElementById('volume-overlay');
      const volumeIcon = document.getElementById('volume-icon');
      const volumeValue = document.getElementById('volume-value');

      // State
      let lastTrackId = '';
      let currentArtist = '';
      let artistImages = [];
      let currentImageIndex = 0;
      let activeBackgroundLayer = 0;
      let rotationTimer = null;
      let pollTimer = null;
      let lastVolume = null;
      let lastMute = null;
      let volumeTimer = null;

      function handleVolumeOverlay(volumeObj) {
        if (!volumeObj) return;
        const raw = typeof volumeObj.value === 'number' ? volumeObj.value : parseFloat(String(volumeObj.value));
        let percentage = 0;
        if (volumeObj.type === 'db' || (Number.isFinite(raw) && raw < 0) || (typeof volumeObj.min === 'number' && volumeObj.min < 0)) {
          const min = typeof volumeObj.min === 'number' ? volumeObj.min : -80;
          const max = typeof volumeObj.max === 'number' ? volumeObj.max : 0;
          const range = max - min || 80;
          percentage = Math.max(0, Math.min(100, Math.round(((raw - min) / range) * 100)));
        } else {
          percentage = Math.max(0, Math.min(100, Math.round(Number.isFinite(raw) ? raw : 0)));
        }

        const isMuted = !!volumeObj.is_muted;
        const volumeChanged = lastVolume !== null && (lastVolume !== percentage || lastMute !== isMuted);

        if (!volumeChanged && lastVolume === null) {
          lastVolume = percentage;
          lastMute = isMuted;
          return;
        }
        if (!volumeChanged) return;

        lastVolume = percentage;
        lastMute = isMuted;

        if (isMuted) {
          volumeIcon.textContent = 'ðŸ”‡';
          volumeValue.innerHTML = '<span class="mute-text">MUTED</span>';
          volumeOverlay.classList.add('visible');
          clearTimeout(volumeTimer);
        } else {
          volumeIcon.textContent = percentage > 60 ? 'ðŸ”Š' : percentage > 0 ? 'ðŸ”‰' : 'ðŸ”ˆ';
          volumeValue.textContent = percentage;
          volumeOverlay.classList.add('visible');
          clearTimeout(volumeTimer);
          volumeTimer = setTimeout(() => volumeOverlay.classList.remove('visible'), 2500);
        }
      }

      async function lmsRequest(pid, command) {
        const response = await fetch(getProxyUrl(), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            host: host,
            port: parseInt(port) || 9000,
            playerId: pid,
            command: command
          })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        return data.result || data;
      }

      async function getPlayers() {
        try {
          const result = await lmsRequest('', ['players', '0', '100']);
          return result.players_loop || [];
        } catch (e) {
          console.error('Failed to get players:', e);
          return [];
        }
      }

      async function getPlayerStatus(pid) {
        try {
          const result = await lmsRequest(pid, ['status', '-', '1', 'tags:aAlcdegiIKloNrstuwy']);
          return result;
        } catch (e) {
          console.error('Failed to get player status:', e);
          return null;
        }
      }

      async function fetchArtistImages(artistName) {
        if (!artistName || artistName === currentArtist) return;
        
        currentArtist = artistName;
        artistImages = [];
        currentImageIndex = 0;
        
        try {
          const response = await fetch(`https://www.theaudiodb.com/api/v1/json/${AUDIODB_API_KEY}/search.php?s=${encodeURIComponent(artistName)}`);
          const data = await response.json();
          
          if (data.artists && data.artists.length > 0) {
            const artist = data.artists[0];
            const images = [];
            
            if (artist.strArtistFanart) images.push(artist.strArtistFanart);
            if (artist.strArtistFanart2) images.push(artist.strArtistFanart2);
            if (artist.strArtistFanart3) images.push(artist.strArtistFanart3);
            if (artist.strArtistFanart4) images.push(artist.strArtistFanart4);
            if (artist.strArtistThumb) images.push(artist.strArtistThumb);
            if (artist.strArtistWideThumb) images.push(artist.strArtistWideThumb);
            
            artistImages = images.filter(url => url && url.length > 0);
            console.log(`Found ${artistImages.length} images for ${artistName}`);
            
            if (artistImages.length > 0) {
              startBackgroundRotation();
            }
          }
        } catch (e) {
          console.error('Failed to fetch artist images:', e);
        }
      }

      function setBackground(url, blurred = false) {
        const target = bgLayers[activeBackgroundLayer === 0 ? 1 : 0];
        const other = bgLayers[activeBackgroundLayer];
        const img = new Image();
        
        img.onload = () => {
          target.style.backgroundImage = `url('${url}')`;
          if (blurred) {
            target.classList.add('blurred');
          } else {
            target.classList.remove('blurred');
          }
          other.classList.remove('active');
          target.classList.add('active');
          activeBackgroundLayer = activeBackgroundLayer === 0 ? 1 : 0;
        };
        
        img.src = url;
      }

      function startBackgroundRotation() {
        if (rotationTimer) {
          clearInterval(rotationTimer);
        }
        
        if (artistImages.length === 0) return;
        
        const rotate = () => {
          const nextIndex = currentImageIndex % artistImages.length;
          setBackground(artistImages[nextIndex], false);
          currentImageIndex = (currentImageIndex + 1) % artistImages.length;
        };
        
        rotate(); // Show first image immediately
        
        if (artistImages.length > 1) {
          rotationTimer = setInterval(rotate, BACKGROUND_ROTATION_MS);
        }
      }

      function setAlbumArt(imageUrl) {
        if (imageUrl) {
          const img = new Image();
          img.onload = () => {
            albumArt.src = imageUrl;
            albumArt.classList.add('loaded');
          };
          img.src = imageUrl;
        } else {
          albumArt.classList.remove('loaded');
          albumArt.removeAttribute('src');
        }
      }

      function updateProgress(progress) {
        progressBar.style.width = `${Math.min(100, Math.max(0, progress))}%`;
      }

      function formatTime(seconds) {
        const safe = Math.max(0, Math.floor(seconds || 0));
        const mins = Math.floor(safe / 60).toString().padStart(1, '0');
        const secs = Math.floor(safe % 60).toString().padStart(2, '0');
        return `${mins}:${secs}`;
      }

      function updateDisplay(status) {
        const isPlaying = status.mode === 'play' || status.mode === 'pause';
        
        if (!isPlaying || !status.playlist_loop || status.playlist_loop.length === 0) {
          notPlayingContainer.classList.remove('hidden');
          bottomBar.classList.add('hidden');
          return;
        }
        
        notPlayingContainer.classList.add('hidden');
        bottomBar.classList.remove('hidden');
        
        const track = status.playlist_loop[0];
        const trackId = track.id || track.title;
        const trackTitle = track.title || 'Unknown';
        const artistName = track.artist || 'Unknown Artist';
        const duration = parseFloat(track.duration) || 0;
        const time = parseFloat(status.time) || 0;
        const progress = duration > 0 ? (time / duration) * 100 : 0;
        
        titleEl.textContent = trackTitle;
        artistEl.textContent = artistName;
        currentTimeEl.textContent = formatTime(time);
        durationEl.textContent = formatTime(duration);
        updateProgress(progress);
        
        // Update artwork and background on track change
        if (trackId !== lastTrackId) {
          lastTrackId = trackId;
          
          // Album artwork:
          // - LMS (and plugins like TIDAL) often return relative paths like "/imageproxy/..." or "/music/...".
          // - Our proxy endpoint is `/api/image-proxy` (not `/api/lms/image-proxy`).
          // - The proxy expects an absolute http(s) URL.
          const lmsBase = `http://${host}:${parseInt(port) || 9000}`;
          let absoluteArtwork = null;
          // Prefer TIDAL direct HTTPS artwork when available (avoids mixed content / proxy oddities)
          const trackUrl = (track.url || '').toString();
          const rawArtwork = track.artwork_url ? String(track.artwork_url) : '';
          if (trackUrl.startsWith('tidal://') && rawArtwork.includes('/imageproxy/') && rawArtwork.includes('resources.tidal.com')) {
            try {
              const m = rawArtwork.match(/\/imageproxy\/([^/]+)\/image\.jpg/i);
              const encodedInner = m?.[1];
              if (encodedInner) {
                let inner = decodeURIComponent(encodedInner);
                if (inner.startsWith('http://resources.tidal.com/')) inner = inner.replace('http://', 'https://');
                inner = inner.replace(/\/1280x1280\.jpg(\b|$)/i, '/640x640.jpg');
                absoluteArtwork = inner;
              }
            } catch {}
          }

          if (!absoluteArtwork && track.coverid) {
            absoluteArtwork = `${lmsBase}/music/${track.coverid}/cover.jpg`;
          } else if (!absoluteArtwork && track.artwork_url) {
            const raw = String(track.artwork_url);
            if (raw.startsWith('http://') || raw.startsWith('https://')) {
              absoluteArtwork = raw;
            } else if (raw.startsWith('/')) {
              absoluteArtwork = `${lmsBase}${raw}`;
            } else {
              absoluteArtwork = `${lmsBase}/${raw}`;
            }
          }
          const artworkUrl = absoluteArtwork
            ? `/api/image-proxy?url=${encodeURIComponent(absoluteArtwork)}`
            : null;
          
          setAlbumArt(artworkUrl);
          
          // Fetch artist images
          if (artistName && artistName !== 'Unknown Artist') {
            fetchArtistImages(artistName);
          }
          
          // Set album art as fallback background
          if (artworkUrl) {
            setBackground(artworkUrl, true);
          }
        }

        // Volume overlay (copied behavior from roon-cast receiver)
        const rawVol = (status['mixer volume'] ?? status.mixer_volume ?? status.volume);
        const volNum = typeof rawVol === 'number' ? rawVol : parseFloat(String(rawVol));
        const rawMute = (status['mixer muting'] ?? status.mixer_muting ?? status.muting);
        const muteNum = typeof rawMute === 'number' ? rawMute : parseInt(String(rawMute), 10);
        if (Number.isFinite(volNum)) {
          handleVolumeOverlay({ type: 'number', min: 0, max: 100, value: volNum, is_muted: muteNum === 1 });
        }
      }

      async function poll() {
        try {
          let pid = playerId;
          
          if (!pid) {
            const players = await getPlayers();
            if (players.length > 0) {
              pid = players[0].playerid;
              playerId = pid;
            }
          }
          
          if (pid) {
            const status = await getPlayerStatus(pid);
            if (status) {
              updateDisplay(status);
            }
          }
        } catch (e) {
          console.error('Poll error:', e);
        }
      }

      // Start polling
      poll();
      pollTimer = setInterval(poll, 2000);
    </script>
  </body>
</html>

